library("forecast")
load(file = "Hoff-fMRI.rda")

## create hemodynamic response function
stimulus <- function (scans = 1, onsets = c(1), durations = c(1), rt = 3, times = NULL, mean = TRUE, a1 = 6, a2 = 12, 
                      b1 = 0.9, b2 = 0.9, cc = 0.35)
{
  mygamma <- function(x, a1, a2, b1, b2, c) {
    d1 <- a1 * b1
    d2 <- a2 * b2
    c1 <- (x/d1)^a1
    c2 <- c * (x/d2)^a2
    res <- c1 * exp(-(x - d1)/b1) - c2 * exp(-(x - d2)/b2)
    res
  }
  if (is.null(times)) {
    scale <- 1
  }
  else {
    scale <- 100
    onsets <- times/rt * scale
    durations <- durations/rt * scale
    rt <- rt/scale
    scans <- scans * scale
  }
  numberofonsets <- length(onsets)
  if (length(durations) == 1) {
    durations <- rep(durations, numberofonsets)
  }
  else if (length(durations) != numberofonsets) {
    stop("Length of duration vector does not match the number of onsets!")
  }
  stimulus <- rep(0, scans)
  for (i in 1:numberofonsets) {
    for (j in onsets[i]:(onsets[i] + durations[i] - 1)) {
      stimulus[j] <- 1
    }
  }
  stimulus <- c(rep(0, 20 * scale), stimulus, rep(0, 20 * scale))
  hrf <- convolve(stimulus, mygamma(((40 * scale) + scans):1,
                                    a1, a2, b1/rt, b2/rt, cc))/scale
  hrf <- hrf[-(1:(20 * scale))][1:scans]
  hrf <- hrf[unique((scale:scans)%/%scale) * scale]
  dim(hrf) <- c(scans/scale, 1)
  if (mean) {
    hrf - mean(hrf)
  }
  else {
    hrf
  }
}
## create orthogonal drift taken from fmri package
design <- function (hrf, order = 2)
{
  stimuli <- dim(hrf)[2]
  scans <- dim(hrf)[1]
  z <- matrix(0, scans, stimuli + order + 1)
  for (i in 1:stimuli) {
    z[, i] <- hrf[, i]
  }
  ortho <- matrix(0, stimuli, stimuli)
  for (i in 1:stimuli) {
    for (j in 1:stimuli) {
      ortho[i, j] <- z[, i] %*% z[, j]
    }
  }
  z[, stimuli + 1] <- 1
  if (order != 0) {
    for (i in (stimuli + 2):(stimuli + order + 1)) {
      z[, i] <- (1:scans)^(i - stimuli - 1)
      z[, i] <- z[, i]/mean(z[, i])
      hz <- numeric(stimuli)
      for (j in 1:stimuli) {
        hz[j] <- z[, j] %*% z[, i]
      }
      tmp <- lm(-hz ~ ortho - 1)
      z[, i] <- z[, i] + as.vector(as.matrix(hrf) %*% as.vector(tmp$coeff))
    }
  }
  z
}

##---- Generate time series for a given map
fMRI.ts <- function(brain.map,act.map, mask = NULL,SNR=5,nscan=1,b0a = 6000, b0b=4500,
                    b1 = 600, b2= -166.5031,b3= NULL, phi = NULL,
                    verbose=FALSE,spatial.smooth=FALSE,fwmh = 4,vdim=c(1,1,1))
{
  
  if(!all(dim(act.map)==dim(brain.map))){
    stop("Brain image and activation map are not equal size \n")
  }
  
  dy <- dim(brain.map)
  voxelcount <- prod(dy)
  if(is.null(b0b)){
    b0b <- b0a
  }
  beta0 <- rep(0,voxelcount)
  beta0[brain.map==1] <- b0a
  beta0[brain.map==0] <- b0b
  beta1 <- rep(0,voxelcount)
  beta1[as.logical(act.map)] <- b1 # activate section
  
  if(is.null(mask)){
    beta2 <- rep(b2,voxelcount)
  } else{
    beta2 <- rep(0,voxelcount)
    beta2[mask==1] <- beta2
  }
  
  ar.order <- ifelse(is.null(phi),0,length(phi)) 
  
  hrf <- stimulus(nscan, (0:7) * 12 + 7, 6, 7) #Stimulus using Diff Gamma
  x <- design(hrf) # Design Matrix
  x <- cbind(1,x[,-c(2,4)])
  betas <- cbind(beta0,beta1,beta2)
  
  Yhat <- betas %*% t(x) # in here FFT
  
  x <- x[,-1] #--- remove intercept
  
  sigma <- b0a/SNR  ## variance
  if(verbose){
    cat(paste("Simulating fMRI time series with AR(",ar.order,") errors.\n",sep=""))
  }
  if(ar.order==0){
    Ystar <- t(apply(Yhat,1,function(z) z + rnorm(nscan,mean = 0, sd = sigma)))
    dim(Ystar) <- c(dy,1,nscan)
  } else{
    Ystar <- t(apply(Yhat,1,function(z) z + arima.sim(model = list(ar=phi),n=nscan,sd=sigma)))
    dim(Ystar) <- c(dy,1,nscan)
  }
  
  if(spatial.smooth){
    if(verbose){
      cat("Spatial-smoothing of the 4D data set.\n")
    }
    sigma <- fwmh/2.235
    Ystar <- AnalyzeFMRI::GaussSmoothArray(x = Ystar,voxdim = vdim,ksize = 5,sigma = sigma* diag(1,nrow=3,ncol=3))
  }
  
  if(verbose){
    cat("Done simulating the fMRI time series with the specified set-up. \n")
  }
  list(Ystar=Ystar,x = x)
}

